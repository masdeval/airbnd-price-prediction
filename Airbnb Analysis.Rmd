---
title: "Airbnb_Analysis"
author: "Xinning Wang"
date: "4/15/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Data cleaning process - Christian
```{r}
anb_original <- read.csv("listings_detail.csv")
anb_safe <- anb_original

library('dplyr')
anb_original$listing_url = NULL
anb_original$scrape_id = NULL 
anb_original$last_scraped = NULL 
anb_original$name = NULL
anb_original$summary = NULL
anb_original$description = NULL
anb_original$experiences_offered = NULL
anb_original$neighborhood_overview = NULL
anb_original$notes = NULL
anb_original$transit = NULL
anb_original$access = NULL
anb_original$interaction = NULL

anb_original$space = as.numeric(anb_original$space)

anb_original$house_rules= anb_original$thumbnail_url = anb_original$medium_url = anb_original$picture_url = anb_original$xl_picture_url = NULL

anb_original$host_url=anb_original$host_name=anb_original$host_since=anb_original$host_location =anb_original$host_about=NULL 

anb_original$host_thumbnail_url=anb_original$host_picture_url=anb_original$host_neighbourhood= anb_original$host_verifications=anb_original$street=anb_original$neighbourhood= anb_original$neighbourhood_group_cleansed=NULL

anb_original$country_code= anb_original$country= anb_original$amenities= anb_original$calendar_updated= anb_original$has_availability=anb_original$availability_30  =anb_original$availability_60=anb_original$availability_90=anb_original$availability_365  =anb_original$calendar_last_scraped = NULL

anb_original$first_review= anb_original$last_review=anb_original$requires_license=anb_original$license = NULL
 
anb_original$price = as.numeric(anb_original$price)
anb_original$weekly_price = as.numeric(anb_original$weekly_price)
anb_original$monthly_price = as.numeric(anb_original$monthly_price)
anb_original$security_deposit = as.numeric(anb_original$security_deposit)
anb_original$extra_people = as.numeric(anb_original$extra_people)
anb_original$cleaning_fee = as.numeric(anb_original$cleaning_fee)

count(anb_original[is.na(anb_original$price),])
count(anb_original[is.na(anb_original$square_feet),])
anb_original$square_feet = NULL

str(anb_original)
```

## More data cleaning process - Xinning
```{r}
# Find count of NAs in columns
num.NA <- sort(sapply(anb_original, function(x) {sum(is.na(x))}), decreasing = TRUE)
num.NA

# Drop columns where too few data point is present
drop_cols <- c("space", "host_acceptance_rate", "monthly_price", "weekly_price")
anb_original <- anb_original[ , !(names(anb_original) %in% drop_cols)]

# Fill certain NAs with zeros
anb_original$security_deposit[is.na(anb_original$security_deposit)] <- 0
anb_original$cleaning_fee[is.na(anb_original$cleaning_fee)] <- 0

# Sorting neighborhoods based on location ratings
neighbourhood.avg_ratings <- data.frame(aggregate(x = anb_original$review_scores_location, by = list(anb_original$neighbourhood_cleansed), FUN = mean, na.rm = TRUE))
ratings_sorted <- neighbourhood.avg_ratings[order(neighbourhood.avg_ratings$x),]
neighborhood_sorted <- list(ratings_sorted$Group.1)

# Factor to numeric
df.neighborhood <- data.frame(matrix(unlist(neighborhood_sorted), nrow=39, byrow=T))
df.neighborhood$index <- seq.int(nrow(df.neighborhood))
names(df.neighborhood) <- c('neighbourhood_cleansed', 'neighbourhood_score')
anb_original <- merge(x=anb_original, y=df.neighborhood, by='neighbourhood_cleansed', all.x = TRUE)
str(anb_original)

# Drop More Cols
anb_original$id <- NULL
anb_original$host_id <- NULL
anb_original$host_acceptance_rate <- NULL
anb_original$city <- NULL
anb_original$state <- NULL
anb_original$zipcode <- NULL
anb_original$market <- NULL
anb_original$smart_location <- NULL
anb_original$latitude <- NULL
anb_original$longitude <- NULL
anb_original$jurisdiction_names <- NULL
```

## Test for normality before linear modeling
```{r}
boxplot(anb_original$price)
title("price boxplot")
qqnorm(anb_original$price) 
qqline(anb_original$price)
length(anb_original$price)
```
Judging from the qqplot, the data is apparently not normally distributed, but since the data have more than 7000 observations, it is large enough to use linear modeling method.

## Variable selection
```{r}
library(leaps)
list_of_numeric_col_names <- c('host_response_rate', 'host_listings_count', 'accommodates', 'bathrooms', 'bedrooms', 'beds', 'security_deposit', 'cleaning_fee', 'guests_included', 'extra_people', 'minimum_nights', 'maximum_nights', 'number_of_reviews', 'review_scores_accuracy', 'review_scores_cleanliness', 'review_scores_checkin', 'review_scores_communication', 'review_scores_location', 'review_scores_value', 'neighbourhood_score', 'price')
numeric_variables <- anb_original[list_of_numeric_col_names]
reg.best <- regsubsets(price~., data = numeric_variables, nvmax = 3)
plot(reg.best, scale = "adjr2", main = "Adjusted R^2")
summary(reg.best)
```

## PCR Analysis
```{r}
library("pls")
library("mice")
library("ISLR")

pcr.fit=pcr(price~., data = numeric_variables, scale=TRUE, validation ="CV")
summary(pcr.fit)
validationplot(pcr.fit ,val.type="MSEP")
validationplot(pcr.fit,val.type="R2")

summary(pcr.fit)
```
From either plots, we are able to determine that we should use 3 components for modeling.

```{r}
pcr.fit$coefficients
airbnb.pcr <- subset(numeric_variables, select = 'price')

coef1 <- coef(pcr.fit, ncomp = 1)
coef2 <- coef(pcr.fit, ncomp = 2)
coef3 <- coef(pcr.fit, ncomp = 3)

# PC1
airbnb.pcr$PC1 <- coef1[1]*numeric_variables$host_response_rate+coef1[2]*numeric_variables$host_listings_count+coef1[3]*numeric_variables$accommodates+coef1[4]*numeric_variables$bathrooms+coef1[5]*numeric_variables$bedrooms+coef1[6]*numeric_variables$beds+coef1[7]*numeric_variables$security_deposit+coef1[8]*numeric_variables$cleaning_fee+coef1[9]*numeric_variables$guests_included+coef1[10]*numeric_variables$extra_people+coef1[11]*numeric_variables$minimum_nights+coef1[12]*numeric_variables$maximum_nights*+coef1[13]*numeric_variables$number_of_reviews+coef1[14]*numeric_variables$review_scores_accuracy+coef1[15]*numeric_variables$review_scores_cleanliness+coef1[16]*numeric_variables$review_scores_checkin+coef1[17]*numeric_variables$review_scores_communication+coef1[18]*numeric_variables$review_scores_location+coef1[19]*numeric_variables$review_scores_value+coef1[20]*numeric_variables$neighbourhood_score

airbnb.pcr$PC2 <- coef2[1]*numeric_variables$host_response_rate+coef2[2]*numeric_variables$host_listings_count+coef2[3]*numeric_variables$accommodates+coef2[4]*numeric_variables$bathrooms+coef2[5]*numeric_variables$bedrooms+coef2[6]*numeric_variables$beds+coef2[7]*numeric_variables$security_deposit+coef2[8]*numeric_variables$cleaning_fee+coef2[9]*numeric_variables$guests_included+coef2[10]*numeric_variables$extra_people+coef2[11]*numeric_variables$minimum_nights+coef2[12]*numeric_variables$maximum_nights*+coef2[13]*numeric_variables$number_of_reviews+coef2[14]*numeric_variables$review_scores_accuracy+coef2[15]*numeric_variables$review_scores_cleanliness+coef2[16]*numeric_variables$review_scores_checkin+coef2[17]*numeric_variables$review_scores_communication+coef2[18]*numeric_variables$review_scores_location+coef2[19]*numeric_variables$review_scores_value+coef2[20]*numeric_variables$neighbourhood_score

airbnb.pcr$PC3 <- coef3[1]*numeric_variables$host_response_rate+coef3[2]*numeric_variables$host_listings_count+coef3[3]*numeric_variables$accommodates+coef3[4]*numeric_variables$bathrooms+coef3[5]*numeric_variables$bedrooms+coef3[6]*numeric_variables$beds+coef3[7]*numeric_variables$security_deposit+coef3[8]*numeric_variables$cleaning_fee+coef3[9]*numeric_variables$guests_included+coef3[10]*numeric_variables$extra_people+coef3[11]*numeric_variables$minimum_nights+coef3[12]*numeric_variables$maximum_nights*+coef3[13]*numeric_variables$number_of_reviews+coef3[14]*numeric_variables$review_scores_accuracy+coef3[15]*numeric_variables$review_scores_cleanliness+coef3[16]*numeric_variables$review_scores_checkin+coef3[17]*numeric_variables$review_scores_communication+coef3[18]*numeric_variables$review_scores_location+coef3[19]*numeric_variables$review_scores_value+coef3[20]*numeric_variables$neighbourhood_score

head(airbnb.pcr)
```

```{r}
airbnb.pcr.lm <- lm(price ~ PC1+PC2+PC3, data = airbnb.pcr)
summary(airbnb.pcr.lm)
```

```{r}
# Taking in factorial variables one by one and decide whether it makes much impact by using ANOVA test
# ANOVA on variable host_is_superhost
group_superhost <- anb_original[anb_original$host_is_superhost == 't', 'price']
group_non_superhost <- anb_original[anb_original$host_is_superhost == 'f', 'price']

combined_groups_superhost <- data.frame(cbind(group_superhost, group_non_superhost))
stacked_groups_superhost <- stack(combined_groups_superhost)

anova_results_superhost <- aov(values ~ ind, data = stacked_groups_superhost)
summary(anova_results_superhost)
```

```{r}
# ANOVA on variable room_type
group_private <- anb_original[anb_original$room_type == 'Private room', 'price']
group_shared <- anb_original[anb_original$room_type == 'Shared room', 'price']
group_entire <- anb_original[anb_original$room_type == 'Entire home/apt', 'price']

combined_groups_roomtype <- data.frame(cbind(group_private, group_shared, group_entire))
stacked_groups_roomtype <- stack(combined_groups_roomtype)

anova_results_roomtype <- aov(values ~ ind, data = stacked_groups_roomtype)
summary(anova_results_roomtype)
```

```{r}
# ANOVA on variable instant_bookable
group_t <- anb_original[anb_original$instant_bookable == 't', 'price']
group_f <- anb_original[anb_original$instant_bookable == 'f', 'price']

combined_groups_bookable <- data.frame(cbind(group_t, group_f))
stacked_groups_bookable <- stack(combined_groups_bookable)

anova_results_bookable <- aov(values ~ ind, data = stacked_groups_bookable)
summary(anova_results_bookable)
```

```{r}
library(dummies)

dummies = dummy.data.frame(anb_original ,all = FALSE)

anb_original$host_is_superhost = NULL
anb_original$host_identity_verified = NULL
anb_original$neighbourhood_cleansed = NULL
anb_original$property_type = NULL
anb_original$require_guest_profile_picture = NULL
anb_original$require_guest_phone_verification = NULL
anb_original$room_type = NULL
anb_original$bed_type = NULL
anb_original$instant_bookable = NULL
anb_original$is_location_exact = NULL
anb_original$cancellation_policy = NULL
anb_original$host_response_time = NULL
anb_original$host_has_profile_pic = NULL

anb_with_dummies <- cbind(anb_original,dummies)
```

```{r}
reg.best <- regsubsets(price~., data = anb_with_dummies, nvmax = 20, method = "forward")
```

```{r}
# numeric_variables$host_response_rate <- NULL
# numeric_variables$host_listings_count <- NULL
# numeric_variables$extra_people <- NULL
# numeric_variables$minimum_nights <- NULL
# numeric_variables$maximum_nights <- NULL
# numeric_variables$review_scores_accuracy <- NULL
# numeric_variables$review_scores_checkin <- NULL
# numeric_variables$review_scores_communication <- NULL
# numeric_variables$cleaning_fee <- NULL
# numeric_variables$guests_included <- NULL

for(i in 1:ncol(anb_with_dummies)){
  anb_with_dummies[is.na(anb_with_dummies[,i]), i] <- mean(anb_with_dummies[,i], na.rm = TRUE)
}
num.NA <- sort(sapply(anb_with_dummies, function(x) {sum(is.na(x))}), decreasing = TRUE)

reg.best <- regsubsets(price~., data = anb_with_dummies, nvmax = 20, method = "forward")

plot(reg.best, scale = "adjr2", main = "Adjusted R^2")

# corrplot::corrplot(cor(numeric_variables),type='upper',method = 'number')
# 
# lm1 <- lm(price~., data = numeric_variables)
# summary(lm1)
```

